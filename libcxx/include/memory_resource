// -*- C++ -*-
//===-------------------------- memory_resource----------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MEMORY_RESOURCE
#define _LIBCPP_MEMORY_RESOURCE

// namespace std::pmr {
//   class memory_resource {
//   public:
//     memory_resource() = default;
//     memory_resource(const memory_resource&) = default;
//     virtual ~memory_resource();

//     memory_resource& operator=(const memory_resource&) = default;

//     void* allocate(size_t bytes, size_t alignment = alignof(max_align_t)); // until C++20
//     [[nodiscard]] void* allocate(size_t bytes, size_t alignment = alignof(max_align_t)); // since C++20

//     bool is_equal(const memory_resource& other) const noexcept;
//   private:
//     virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
//     virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;

//     virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;

//   }; // class memory_resource

//   memory_resource* new_delete_resource() noexcept;
//   memory_resource* null_memory_resource() noexcept;

//   memory_resource* set_default_resource(memory_resource* r) noexcept;
//   memory_resource* get_default_resource() noexcept;

//   template <class Tp>             // until C++20
//   template <class Tp = std::byte> // since C++20
//   class polymorphic_allocator {
//   public:
//     using value_type = Tp;

//     polymorphic_allocator() noexcept;
//     polymorphic_allocator(memory_resource* r);

//     polymorphic_allocator(const polymorphic_allocator& other) = default;

//     template <class U>
//       polymorphic_allocator(const polymorphic_allocator<U>& other) noexcept;

//     polymorphic_allocator&
//       operator=(const polymorphic_allocator& rhs) = delete;

//     Tp* allocate(size_t n);                                                                          // until C++20
//     [[nodiscard]] Tp* allocate(size_t n);                                                            // since C++20
//     void deallocate(Tp* p, size_t n);

//     [[nodiscard]] void* allocate_bytes(size_t nbytes, size_t alignment = alignof(std::max_align_t)); // since C++20
//     void deallocate_bytes(void* p, size_t nbytes, size_t alignment = alignof(std::max_align_t));     // since C++20

//     template <class T>
//       [[nodiscard]] T* allocate_object(size_t n = 1);                                                // since C++20
//     template <class T>
//       void deallocate_object(T* p, size_t n = 1);                                                    // since C++20

//     template <class T, class... CtorArgs>
//       [[nodiscard]] T* new_object(CtorArgs&&... ctor_args);                                          // since C++20
//     template <class T>
//       void delete_object(T* p);                                                                      // since C++20

//     template <class T, class... Args>
//     void construct(T* p, Args&&... args);

//     template <class T1, class T2, class... Args1, class... Args2>
//       void construct(pair<T1, T2>* p, piecewise_construct_t,
//                      tuple<Args1...> x, tuple<Args2...> y);                                          // until C++20
//     template <class T1, class T2>
//       void construct(pair<T1, T2>* p);                                                               // until C++20
//     template <class T1, class T2, class U, class V>
//       void construct(pair<T1, T2>* p, U&& x, V&& y);                                                 // until C++20
//     template <class T1, class T2, class U, class V>
//       void construct(pair<T1, T2>* p, const pair<U, V>& pr);                                         // until C++20
//     template <class T1, class T2, class U, class V>
//       void construct(pair<T1, T2>* p, pair<U, V>&& pr);                                              // until C++20

//     template <class T>
//       void destroy(T* p);                                                                            // deprecated since C++20

//     polymorphic_allocator select_on_container_copy_construction() const;

//     memory_resource* resource() const;
//   }; // class polymorphic_allocator

//   template <class T1, class T2>
//   bool operator==(const polymorphic_allocator<T1>& a,
//                   const polymorphic_allocator<T2>& b) noexcept;

//   template <class T1, class T2>
//   bool operator!=(const polymorphic_allocator<T1>& a,
//                   const polymorphic_allocator<T2>& b) noexcept;                                      // until C++20
// }

#include <__config>
#include <__memory/uses_allocator_args.h>
#include <cstddef>
#include <limits>
#include <memory>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_PMR

class _LIBCPP_TYPE_VIS memory_resource
{
  static constexpr size_t __max_align = _LIBCPP_ALIGNOF(max_align_t);
public:
  memory_resource() = default;
  memory_resource(const memory_resource&) = default;

  virtual ~memory_resource() = default;


  _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY
  void* allocate(size_t __bytes, size_t __alignment = __max_align)
  {
      return do_allocate(__bytes, __alignment);
  }

  _LIBCPP_INLINE_VISIBILITY
  void deallocate(void* __p, size_t __bytes, size_t __alignment = __max_align)
  {
      return do_deallocate(__p, __bytes, __alignment);
  }

  _LIBCPP_INLINE_VISIBILITY
  bool is_equal(const memory_resource& __other) const _NOEXCEPT
  {
      return do_is_equal(__other);
  }
private:
  virtual void* do_allocate(size_t, size_t) = 0;
  virtual void do_deallocate(void*, size_t, size_t) = 0;
  virtual bool do_is_equal(const memory_resource&) const _NOEXCEPT = 0;

  _LIBCPP_INLINE_VISIBILITY
  friend bool operator==(const memory_resource& __lhs,
                         const memory_resource& __rhs) _NOEXCEPT
  {
    return &__lhs == &__rhs || __lhs.is_equal(__rhs);
  }

#if _LIBCPP_STD_VER <= 17
  _LIBCPP_INLINE_VISIBILITY
  friend bool operator!=(const memory_resource& __lhs,
                         const memory_resource& __rhs) _NOEXCEPT
  {
    return !(__lhs == __rhs);
  }
#endif
}; // class memory_resource

_LIBCPP_FUNC_VIS
memory_resource* new_delete_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource* null_memory_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource* set_default_resource(memory_resource*) _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource* get_default_resource() _NOEXCEPT;

template <class _Tp
#if _LIBCPP_STD_VER > 17
           = byte
#endif
>
class polymorphic_allocator {
public:
    using value_type = _Tp;

    polymorphic_allocator() _NOEXCEPT
        : __resource(get_default_resource()) {}

    polymorphic_allocator(memory_resource* __r)
        : __resource(__r) {}

    polymorphic_allocator(const polymorphic_allocator&) = default;

    template <class _Up>
    polymorphic_allocator(const polymorphic_allocator<_Up>& __other) _NOEXCEPT
        : __resource(__other.resource()) {}

    polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;

    _LIBCPP_NODISCARD_AFTER_CXX17 _Tp* allocate(size_t __n)
    {
        if (__n > numeric_limits<size_t>::max() / sizeof(_Tp)) {
            __throw_bad_array_new_length();
        }
        return static_cast<_Tp*>(__resource->allocate(__n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp)));
    }

    void deallocate(_Tp* __p, size_t __n)
    {
        __resource->deallocate(__p, __n * sizeof(_Tp), _LIBCPP_ALIGNOF(_Tp));
    }

#if _LIBCPP_STD_VER > 17
    _LIBCPP_NODISCARD void* allocate_bytes(size_t __nbytes,
                                           size_t __alignment = _LIBCPP_ALIGNOF(max_align_t))
    {
        return __resource->allocate(__nbytes, __alignment);
    }

    void deallocate_bytes(void* __p, size_t __nbytes,
                          size_t __alignment = _LIBCPP_ALIGNOF(max_align_t))
    {
        __resource->deallocate(__p, __nbytes, __alignment);
    }

    template <class _Up>
    _LIBCPP_NODISCARD _Up* allocate_object(size_t __n = 1)
    {
        if (__n > numeric_limits<size_t>::max() / sizeof(_Up)) {
            __throw_bad_array_new_length();
        }
        return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up), _LIBCPP_ALIGNOF(_Up)));
    }

    template <class _Up>
    void deallocate_object(_Up* __p, size_t __n = 1)
    {
        deallocate_bytes(__p, __n * sizeof(_Up), _LIBCPP_ALIGNOF(_Up));
    }

    template <class _Up, class... _CtorArgs>
    _LIBCPP_NODISCARD _Up* new_object(_CtorArgs&&... __ctor_args)
    {
        _Up* __object_ptr = allocate_object<_Up>();
#ifndef _LIBCPP_NO_EXCEPTIONS
        try
        {
#endif
            construct(__object_ptr, _VSTD::forward<_CtorArgs>(__ctor_args)...);
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
        catch (...)
        {
            deallocate_object(__object_ptr);
            throw;
        }
#endif
        return __object_ptr;
    }

    template <class _Up>
    void delete_object(_Up* __ptr)
    {
        allocator_traits<polymorphic_allocator>::destroy(*this, __ptr);
        deallocate_object(__ptr);
    }
#endif // _LIBCPP_STD_VER > 17

    template <class _Up, class... _Args>
    void construct(_Up* __p, _Args&&... __args)
    {
        __uninitialized_construct_using_allocator(__p, __resource, _VSTD::forward<_Args>(__args)...);
    }

    template <class _Up>
    void destroy(_Up* __p)
    {
        __p->~_Up();
    }

    polymorphic_allocator select_on_container_copy_construction() const
    {
        return polymorphic_allocator();
    }

    memory_resource* resource() const
    {
        return __resource;
    }
private:
    memory_resource* __resource;
}; // class polymorphic_allocator

template <class _Tp, class _Up>
bool operator==(const polymorphic_allocator<_Tp>& __a, const polymorphic_allocator<_Up>& __b) _NOEXCEPT
{
    return *__a.resource() == *__b.resource();
}

template <class _Tp, class _Up>
bool operator!=(const polymorphic_allocator<_Tp>& __a, const polymorphic_allocator<_Up>& __b) _NOEXCEPT
{
    return !(__a == __b);
}

_LIBCPP_END_NAMESPACE_PMR

#endif // _LIBCPP_MEMORY_RESOURCE
